#include "ui/Config.hpp"
#include "ui/Terminal.hpp"
#include <algorithm>
#include <cctype>
#include <chrono>
#include <cstdlib>
#include <filesystem>
#include <fstream>
#include <iterator>
#include <string>
#include <vector>

namespace montauk::ui {

UIState g_ui{};

static const char* kDefaultThemeEnv =
  "# Auto-generated by Montauk: default amber theme\n"
  "MONTAUK_TEXT_HEX=#FFB000\n"
  "MONTAUK_TITLE_HEX=#FFB000\n"
  "MONTAUK_ACCENT_HEX=#FFB000\n"
  "MONTAUK_CAUTION_HEX=#FFF6A7\n"
  "MONTAUK_WARNING_HEX=#EA1717\n"
  "MONTAUK_SUCCESS_HEX=#00FFA6\n"
  "MONTAUK_INFO_HEX=#FFB000\n"
  "MONTAUK_MUTED_HEX=#FFB000\n"
  "MONTAUK_ACCENT_IDX=214\n"
  "MONTAUK_CAUTION_IDX=229\n"
  "MONTAUK_WARNING_IDX=196\n"
  "MONTAUK_SUCCESS_IDX=214\n"
  "MONTAUK_INFO_IDX=214\n"
  "MONTAUK_MUTED_IDX=214\n";

bool parse_hex_rgb(const std::string& hex, int& r, int& g, int& b) {
  if (hex.size()!=7 || hex[0] != '#') return false;
  auto hexv = [&](char c)->int{ if (c>='0'&&c<='9') return c-'0'; if (c>='a'&&c<='f') return c-'a'+10; if (c>='A'&&c<='F') return c-'A'+10; return -1; };
  int v1=hexv(hex[1]), v2=hexv(hex[2]), v3=hexv(hex[3]), v4=hexv(hex[4]), v5=hexv(hex[5]), v6=hexv(hex[6]);
  if (v1<0||v2<0||v3<0||v4<0||v5<0||v6<0) return false;
  r = v1*16+v2; g = v3*16+v4; b = v5*16+v6; return true;
}

std::string trim_copy(std::string s) {
  auto is_ws = [](unsigned char c){ return std::isspace(c) != 0; };
  auto it = std::find_if_not(s.begin(), s.end(), is_ws);
  if (it == s.end()) return std::string();
  auto rit = std::find_if_not(s.rbegin(), s.rend(), is_ws);
  return std::string(it, rit.base());
}

std::string to_upper_ascii(std::string s) {
  for (char& c : s) c = (char)std::toupper((unsigned char)c);
  return s;
}

std::string expand_tilde(const std::string& path) {
  if (path.empty()) return path;
  if (path[0] != '~') return path;
  const char* home = std::getenv("HOME");
  if (!home || !*home) return path;
  if (path.size() == 1) return std::string(home);
  if (path[1] == '/' || path[1] == '\\') return std::string(home) + path.substr(1);
  return path;
}

std::string config_dir_base() {
  if (const char* xdg = std::getenv("XDG_CONFIG_HOME"); xdg && *xdg) {
    return std::string(xdg) + "/montauk";
  }
  const char* home = std::getenv("HOME");
  if (home && *home) return std::string(home) + "/.config/montauk";
  return std::string();
}

void install_default_theme_if_needed() {
  static bool attempted = false;
  if (attempted) return;
  attempted = true;
  std::string base = config_dir_base();
  if (base.empty()) return;
  namespace fs = std::filesystem;
  std::error_code ec;
  fs::create_directories(base, ec);
  fs::path dest = fs::path(base) / "theme.env";
  if (fs::exists(dest, ec)) {
    std::ifstream existing(dest);
    if (existing.good()) {
      std::string current((std::istreambuf_iterator<char>(existing)), std::istreambuf_iterator<char>());
      if (!current.empty()) {
        if (current == kDefaultThemeEnv) return;
        // File exists with custom content, don't overwrite
        return;
      }
    }
  }
  std::ofstream out(dest);
  if (!out.good()) return;
  out << kDefaultThemeEnv;
}

const std::unordered_map<std::string, std::string>& theme_overrides() {
  static bool inited = false;
  static std::unordered_map<std::string, std::string> kv;
  static std::chrono::steady_clock::time_point last_load;
  
  auto now = std::chrono::steady_clock::now();
  // Reload theme file every 2 seconds to pick up changes
  if (!inited || std::chrono::duration_cast<std::chrono::seconds>(now - last_load).count() >= 2) {
    inited = true;
    last_load = now;
    kv.clear();
    install_default_theme_if_needed();

    auto load_file = [&](const std::string& candidate)->bool{
      if (candidate.empty()) return false;
      std::ifstream in(candidate);
      if (!in.good()) return false;
      std::string line;
      while (std::getline(in, line)) {
        std::string trimmed = trim_copy(line);
        if (trimmed.empty()) continue;
        if (trimmed[0] == '#') continue;
        auto hash = trimmed.find('#');
        if (hash != std::string::npos) {
          trimmed = trim_copy(trimmed.substr(0, hash));
          if (trimmed.empty()) continue;
        }
        auto eq = trimmed.find('=');
        if (eq == std::string::npos) continue;
        std::string key = trim_copy(trimmed.substr(0, eq));
        std::string value = trim_copy(trimmed.substr(eq + 1));
        if (key.empty()) continue;
        if (!value.empty() && value.front() == '"' && value.back() == '"' && value.size() >= 2) {
          value = value.substr(1, value.size() - 2);
        } else if (!value.empty() && value.front() == '\'' && value.back() == '\'' && value.size() >= 2) {
          value = value.substr(1, value.size() - 2);
        }
        key = to_upper_ascii(key);
        kv[key] = value;
      }
      return true;
    };

    std::vector<std::string> candidates;
    if (const char* theme = std::getenv("MONTAUK_THEME"); theme && *theme) {
      candidates.emplace_back(theme);
    }
    if (auto base = config_dir_base(); !base.empty()) {
      candidates.emplace_back(base + "/theme.env");
    }

    for (const auto& cand : candidates) {
      std::string path = expand_tilde(cand);
      if (load_file(path)) break;
    }
  }
  return kv;
}

const char* getenv_compat(const char* name) {
  const char* v = std::getenv(name);
  if (v && *v) return v;
  const auto& overrides = theme_overrides();
  std::string key_upper = to_upper_ascii(std::string(name));
  if (auto it = overrides.find(key_upper); it != overrides.end() && !it->second.empty()) {
    return it->second.c_str();
  }
  // Accept both legacy MONTAUK_ and new montauk_ prefixes
  std::string alt;
  std::string n(name);
  if (n.rfind("MONTAUK_", 0) == 0) {
    alt = std::string("montauk_") + n.substr(8);
  } else if (n.rfind("montauk_", 0) == 0) {
    alt = std::string("MONTAUK_") + n.substr(8);
  }
  if (!alt.empty()) {
    v = std::getenv(alt.c_str());
    if (v && *v) return v;
    std::string alt_upper = to_upper_ascii(alt);
    if (auto ita = overrides.find(alt_upper); ita != overrides.end() && !ita->second.empty()) {
      return ita->second.c_str();
    }
  }
  return nullptr;
}

int getenv_int(const char* name, int defv) {
  const char* v = getenv_compat(name);
  if (!v || !*v) return defv;
  try { return std::stoi(v); } catch(...) { return defv; }
}

UIState::CPUScale getenv_cpu_scale(const char* name, UIState::CPUScale defv){
  const char* v = getenv_compat(name);
  if (!v || !*v) return defv;
  std::string s = v; for (auto& c : s) c = std::tolower((unsigned char)c);
  if (s=="core"||s=="percore"||s=="irix") return UIState::CPUScale::Core;
  if (s=="total"||s=="machine"||s=="share") return UIState::CPUScale::Total;
  return defv;
}

const UIConfig& ui_config() {
  static UIConfig cfg{};
  static auto last_check = std::chrono::steady_clock::time_point{};
  auto now = std::chrono::steady_clock::now();
  
  if (last_check == std::chrono::steady_clock::time_point{} || 
      std::chrono::duration_cast<std::chrono::seconds>(now - last_check).count() >= 2) {
    last_check = now;
    theme_overrides();
    
    UIConfig c{};
    int acc_idx = getenv_int("MONTAUK_ACCENT_IDX", 11);
    int cau_idx = getenv_int("MONTAUK_CAUTION_IDX", 9);
    int war_idx = getenv_int("MONTAUK_WARNING_IDX", 1);
    int ttl_idx = getenv_int("MONTAUK_TITLE_IDX", 31);
    bool tc = truecolor_capable();
    
    if (const char* accent_hex = getenv_compat("MONTAUK_ACCENT_HEX"); accent_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(accent_hex, r,g,b)) c.accent = sgr_truecolor(r,g,b);
    }
    if (const char* caution_hex = getenv_compat("MONTAUK_CAUTION_HEX"); caution_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(caution_hex, r,g,b)) c.caution = sgr_truecolor(r,g,b);
    }
    if (const char* warning_hex = getenv_compat("MONTAUK_WARNING_HEX"); warning_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(warning_hex, r,g,b)) c.warning = sgr_truecolor(r,g,b);
    }
    if (c.accent.empty())  c.accent  = sgr_palette_idx(acc_idx);
    if (c.caution.empty()) c.caution = sgr_palette_idx(cau_idx);
    if (c.warning.empty()) c.warning = sgr_palette_idx(war_idx);
    
    const char* th = getenv_compat("MONTAUK_TITLE_HEX");
    if (th && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(th, r,g,b)) c.title = sgr_truecolor(r,g,b);
    }
    if (c.title.empty()) c.title = sgr_palette_idx(ttl_idx);
    
    const char* base_hex = getenv_compat("MONTAUK_TEXT_HEX");
    if (base_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(base_hex, r,g,b)) c.base = sgr_truecolor(r,g,b);
    }
    if (c.base.empty()) {
      int base_idx = getenv_int("MONTAUK_TEXT_IDX", 7);
      c.base = sgr_palette_idx(base_idx);
    }
    const char* success_hex = getenv_compat("MONTAUK_SUCCESS_HEX");
    if (success_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(success_hex, r,g,b)) c.success = sgr_truecolor(r,g,b);
    }
    if (c.success.empty()) {
      int success_idx = getenv_int("MONTAUK_SUCCESS_IDX", 10);
      c.success = sgr_palette_idx(success_idx);
    }
    const char* info_hex = getenv_compat("MONTAUK_INFO_HEX");
    if (info_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(info_hex, r,g,b)) c.info = sgr_truecolor(r,g,b);
    }
    if (c.info.empty()) {
      int info_idx = getenv_int("MONTAUK_INFO_IDX", 14);
      c.info = sgr_palette_idx(info_idx);
    }
    const char* muted_hex = getenv_compat("MONTAUK_MUTED_HEX");
    if (muted_hex && tc) {
      int r=0,g=0,b=0; if (parse_hex_rgb(muted_hex, r,g,b)) c.muted = sgr_truecolor(r,g,b);
    }
    if (c.muted.empty()) {
      int muted_idx = getenv_int("MONTAUK_MUTED_IDX", 8);
      c.muted = sgr_palette_idx(muted_idx);
    }
    c.caution_pct = getenv_int("MONTAUK_PROC_CAUTION_PCT", 60);
    c.warning_pct = getenv_int("MONTAUK_PROC_WARNING_PCT", 80);
    
    cfg = c;
  }
  return cfg;
}

void reset_ui_defaults() {
  g_ui.sort = SortMode::CPU;
  g_ui.scroll = 0;
  g_ui.system_focus = false;
  g_ui.show_disk = true;
  g_ui.show_net = true;
  g_ui.show_gpumon = true;
  g_ui.cpu_scale = UIState::CPUScale::Total;
  g_ui.gpu_scale = UIState::GPUScale::Utilization;
}

} // namespace montauk::ui
